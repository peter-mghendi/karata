@page "/game/{id:guid}/play"

@using System.Collections.Immutable
@using System.Reactive.Disposables
@using System.Reactive.Disposables.Fluent
@using System.Reactive.Linq
@using Karata.Pebble.Interceptors
@using Karata.Shared.Client
@using Karata.Shared.State
@using Microsoft.AspNetCore.Components.WebAssembly.Authentication
@using Microsoft.AspNetCore.Components.WebAssembly.Hosting
@using TextCopy

@attribute [Authorize]

@implements IDisposable

@inject AuthenticationStateProvider Authenticator
@inject IAccessTokenProvider Provider
@inject IDialogService DialogService
@inject ILoggerFactory LoggerFactory
@inject ISnackbar Snackbar
@inject NavigationManager Navigator
@inject IWebAssemblyHostEnvironment Environment

<GameConnectionGuard Connection="_connection">
    <MudLoading Loading="@(_room is null)" Text="Please wait..." Class="mud-height-full pa-0">
        <MudContainer MaxWidth="MaxWidth.ExtraLarge" Class="mud-height-full pa-0">
            @if (_room is not null)
            {
                <MudGrid Class="mud-height-full px-4 pt-4">
                    <MudItem xs="12" md="8" xl="9" xxl="10">
                        @* TODO: What is this 88vh? *@
                        <MudCard Elevation="0" Style="background-color: transparent; height: 88vh">
                            @if (_room!.State.Game.Status is GameStatus.Ongoing)
                            {
                                if (_table)
                                {
                                    <CardTableGameInterface Game="_room.State.Game"
                                                            Hand="CurrentHand"
                                                            Turn="_turn.State"
                                                            OnAddCardToTurn="info => _turn.Mutate(new TurnState.Insert(info))"
                                                            OnReorderCardInTurn="info => _turn.Mutate(new TurnState.Reorder(info))"
                                                            OnRemoveCardFromTurn="card => _turn.Mutate(new TurnState.Remove(card))"/>
                                }
                                else
                                {
                                    <CardListGameInterface Game="_room.State.Game"
                                                           Hand="CurrentHand"
                                                           Turn="_turn.State"
                                                           OnAddCardToTurn="info => _turn.Mutate(new TurnState.Insert(info))"
                                                           OnReorderCardInTurn="info => _turn.Mutate(new TurnState.Reorder(info))"
                                                           OnRemoveCardFromTurn="card => _turn.Mutate(new TurnState.Remove(card))"/>
                                }
                            }
                            else
                            {
                                <div class="d-flex flex-column justify-center align-content-center pa-4 pt-8">
                                    <MudText Align="Align.Center" Typo="Typo.h5" Class="gray-text mb-2">
                                        Waiting for players...
                                    </MudText>
                                    <MudText Align="Align.Center" Typo="Typo.h3" Class="mb-4">
                                    <span
                                        style="@(_room.State.Game.Hands.Count is < 2 or > 4 ? "color: var(--mud-palette-error)" : "color: var(--mud-palette-success)")">
                                        @_room.State.Game.Hands.Count    
                                    </span>
                                        of 4
                                    </MudText>
                                    <MudText Align="Align.Center" Typo="Typo.body2" Class="gray-text">
                                        Room ID
                                    </MudText>
                                    <MudText Align="Align.Center" Typo="Typo.body1" Class="mb-2">
                                        @_room.State.Id
                                        <MudIconButton Size="Size.Small" Icon="@Icons.Material.Filled.ContentCopy"
                                                       Color="Color.Primary" OnClick="@CopyRoomId"/>
                                    </MudText>
                                    <MudText Align="Align.Center" Typo="Typo.body2" Class="gray-text">
                                        Room link
                                    </MudText>
                                    <MudText Align="Align.Center" Typo="Typo.body2" Class="mb-8">
                                        @Navigator.Uri
                                        <MudIconButton Size="Size.Small" Icon="@Icons.Material.Filled.ContentCopy"
                                                       Color="Color.Primary" OnClick="@CopyRoomLink"/>
                                    </MudText>
                                    <MudGrid Spacing="2" Justify="Justify.Center">
                                        <MudItem xs="12" sm="8" md="6" lg="4" xl="3" xxl="2">
                                            <QRCode Data="@Navigator.Uri"/>
                                        </MudItem>
                                    </MudGrid>
                                </div>
                            }
                        </MudCard>
                    </MudItem>
                    <MudItem Class="mud-height-full overflow-y-scroll" xs="12" md="4" xl="3" xxl="2">
                        <MudPaper Elevation="0" Class="mb-4">
                            <MudToolBar>
                                @if (_room!.State.Game.Status is GameStatus.Ongoing)
                                {
                                    <MudTooltip Text="Pick card(s)">
                                        <MudIconButton Icon="@Icons.Material.Rounded.ArrowCircleUp"
                                                       Color="Color.Inherit" OnClick="@PerformEmptyTurn"/>
                                    </MudTooltip>
                                    <MudTooltip Text="Play card(s)">
                                        <MudIconButton Icon="@Icons.Material.Rounded.ArrowCircleDown"
                                                       Color="Color.Inherit" OnClick="@PerformCurrentTurn"/>
                                    </MudTooltip>
                                }
                                else
                                {
                                    <MudTooltip
                                        Text="@(IsAdministrator ? "Start Game" : "Only the admin can start the game.")">
                                        <MudIconButton Icon="@Icons.Material.Rounded.PlayArrow" Color="Color.Inherit"
                                                       OnClick="@StartGame" Disabled="!IsAdministrator"/>
                                    </MudTooltip>
                                }

                                <MudTooltip Text="Leave Room">
                                    <MudIconButton Icon="@Icons.Material.Rounded.PersonRemove" Color="Color.Inherit"
                                                   OnClick="@LeaveRoom"/>
                                </MudTooltip>
                            </MudToolBar>
                        </MudPaper>

                        <MudPaper Class="pa-4 mb-4" Elevation="0">
                            <div class="mb-2">
                                <MudSwitch @bind-Value="_table" Color="Color.Primary"
                                           Label="Table interface (Experimental)"
                                           Disabled="@(_room!.State.Game.Status is not GameStatus.Ongoing)"/>
                            </div>
                            <MudText Typo="Typo.caption" Class="text-gray">
                                The table interface is still under development and, as such, may contain bugs.
                            </MudText>
                        </MudPaper>

                        <MudPaper Class="pa-4 mb-4" Elevation="0">
                            <div class="mb-2">
                                <MudSwitch @bind-Value="_learner" Color="Color.Primary"
                                           Label="Learner mode (Experimental)"
                                           Disabled="@(_room!.State.Game.Status is not GameStatus.Ongoing)"/>
                            </div>
                            <MudText Typo="Typo.caption" Class="text-gray">Shows hints.</MudText>
                        </MudPaper>

                        <MudExpansionPanels Outlined="false" Elevation="0" Class="mb-4">
                            @if (_learner && _room!.State.Game.Status is GameStatus.Ongoing)
                            {
                                <MudExpansionPanel Text="Learner mode">
                                    <TurnEffects Game="_room!.State.Game" Cards="@([.._turn.State])"/>
                                </MudExpansionPanel>
                            }
                            <MudExpansionPanel Text="Information">
                                <InformationPanel Room="_room!.State"/>
                            </MudExpansionPanel>
                            <MudExpansionPanel Text="Players">
                                <PlayersPanel Me="CurrentHand.Player" Room="_room.State" Controls="IsAdministrator"
                                              OnSetAway="SetAway" OnVoidTurn="VoidTurn"/>
                            </MudExpansionPanel>
                            <MudExpansionPanel Text="Chat" MaxHeight="480" Class="overflow-y-auto">
                                <ChatPanel Room="_room!.State" Me="CurrentHand.Player" OnSend="Send"/>
                            </MudExpansionPanel>
                        </MudExpansionPanels>
                    </MudItem>
                </MudGrid>
            }
        </MudContainer>
    </MudLoading>
</GameConnectionGuard>

@code
{
    [Parameter] public Guid Id { get; set; }

    [Inject] public required IClipboard Clipboard { get; set; }

    private bool _learner;
    private bool _table;

    private PlayerRoomConnection? _connection;
    private RoomState? _room;
    private TurnState _turn = new([], []);
    private string? _username;
    private readonly CompositeDisposable _subscriptions = new();

    private HandData CurrentHand => _room!.State.Game.Hands.Single(h => h.Player.Username == _username);
    private bool IsAdministrator => CurrentHand.Player == _room?.State.Administrator;

    private void OnStoreChanged<T>(T data) where T : class => StateHasChanged();

    protected override async Task OnInitializedAsync()
    {
        var auth = await Authenticator.GetAuthenticationStateAsync();
        _username = auth.User.Identity!.Name!;

        _connection = new PlayerRoomConnection(new Uri(Environment.BaseAddress), Id)
        {
            AccessTokenProvider = async () =>
            {
                var result = await Provider.RequestAccessToken();
                result.TryGetToken(out var token);
                return token!.Value;
            },
            RoomPasswordProvider = async () =>
            {
                bool repeat;
                do
                {
                    var dialog = await DialogService.ShowAsync<PasswordRequestModal>("Enter password");
                    var result = await dialog.Result;

                    if (result?.Data is string passcode) return passcode;

                    var back = DialogService.ShowMessageBox("Go back?", "Exit to 'Join Game' screen?", "Exit", "Try again");
                    repeat = await back is false;
                } while (repeat);

                Navigator.NavigateTo("/game/join");
                return null;
            },
        };

        _connection.Events.AddHandToRoom.Subscribe(data =>
        {
            var (_, user, _) = data;
            Snackbar.Add($"{user.Username} has joined the room", Severity.Info, c => c.SnackbarVariant = Variant.Text);
        }).DisposeWith(_subscriptions);

        _connection.Events.AddToRoom.Subscribe(room =>
        {
            _room = new RoomState(room, [
                new LoggingInterceptor<RoomData>(LoggerFactory),
                new TimingInterceptor<RoomData>(LoggerFactory)
            ]);
            _turn = new TurnState([], [
                new LoggingInterceptor<ImmutableList<Card>>(LoggerFactory),
                new TimingInterceptor<ImmutableList<Card>>(LoggerFactory)
            ]);

            _room.Changes
                .Merge<object>(_turn.Changes)
                .Throttle(TimeSpan.FromMilliseconds(500))
                .Subscribe(OnStoreChanged)
                .DisposeWith(_subscriptions);

            _connection.Events.BindRoomState(_room).DisposeWith(_subscriptions);
            StateHasChanged();
        }).DisposeWith(_subscriptions);

        _connection.Events.EndGame
            .Select(_ => Observable.FromAsync(async _ =>
                {
                    await _connection.StopAsync();
                    Navigator.NavigateTo($"/game/{_room!.State.Id.ToString()}/over");
                }
            ))
            .Concat()
            .Subscribe()
            .DisposeWith(_subscriptions);

        _connection.Events.NotifyTurnProcessed.Subscribe(_ => _turn.Mutate(new TurnState.Clear())).DisposeWith(_subscriptions);

        _connection.Events.ReceiveChat.Subscribe(message =>
        {
            if (message.Sender.Username != _username)
            {
                Snackbar.Add(
                    @<div>
                        <p class="mud-typography-body2">@message.Sender.Username:</p>
                        <p class="mud-typography-body1">@message.Text</p>
                    </div>,
                    Severity.Normal,
                    c => c.SnackbarVariant = Variant.Text
                );
            }
        }).DisposeWith(_subscriptions);

        _connection.Events.ReceiveSystemMessage.Subscribe(message =>
        {
            var severity = message.Type switch
            {
                MessageType.Error => Severity.Error,
                MessageType.Info => Severity.Info,
                MessageType.Success => Severity.Success,
                MessageType.Warning => Severity.Warning,
                _ => throw new ArgumentException("Invalid message type.", nameof(MessageType))
            };
            Snackbar.Add(message.Text, severity, c => c.SnackbarVariant = Variant.Text);
        }).DisposeWith(_subscriptions);

        _connection.Events.RemoveFromRoom
            .Select(_ => Observable.FromAsync(async _ =>
                {
                    var uri = $"/game/{_room!.State.Id}";

                    _room!.Dispose();
                    _turn.Dispose();

                    StateHasChanged();

                    await _connection.StopAsync();
                    Navigator.NavigateTo(uri);
                }
            ))
            .Concat()
            .Subscribe()
            .DisposeWith(_subscriptions);

        _connection.Events.RemoveHandFromRoom.Subscribe(user => { Snackbar.Add($"{user.Username} has left the room.", Severity.Info, c => c.SnackbarVariant = Variant.Text); }).DisposeWith(_subscriptions);

        _connection.Events.UpdateGameStatus.Subscribe(status => { Snackbar.Add($"The game is now {status.ToString().ToLower()}.", Severity.Info, c => c.SnackbarVariant = Variant.Text); }).DisposeWith(_subscriptions);

        _connection.Events.UpdateHandStatus.Subscribe(data =>
        {
            var (user, status) = data;
            Snackbar.Add($"{user.Username} is now {status.ToString().ToLower()}.", Severity.Info, c => c.SnackbarVariant = Variant.Text);
        }).DisposeWith(_subscriptions);

        _connection.Events.UpdateTurn.Subscribe(turn =>
        {
            var current = _room!.State.Game.Hands[turn].Player.Username;
            var possessive = current == _username ? "your" : $"{current}'s";
            Snackbar.Add($"It is now {possessive} turn.", Severity.Info, c => c.SnackbarVariant = Variant.Text);
        }).DisposeWith(_subscriptions);

        await _connection.StartAsync(
            onRequestCard: async specific =>
            {
                var parameters = new DialogParameters { { nameof(CardRequestModal.Specific), specific } };
                var dialog = await DialogService.ShowAsync<CardRequestModal>("Request a card", parameters);
                var result = await dialog.Result;

                return result?.Data as Card;
            },
            onRequestLastCard: async () =>
            {
                const string blurb = "Declare <b>last card</b> if you have a card or cards that you can legally finish the game with in the next turn.";
                var dialog = DialogService.ShowMessageBox("Last Card?", new MarkupString(blurb), "Yes!", "No");
                return await dialog ?? false;
            }
        );
    }

    async Task LeaveRoom() => await _connection!.LeaveRoom();

    async Task StartGame() => await _connection!.StartGame();

    async Task PerformCurrentTurn() => await PerformTurn([.._turn.State]);

    async Task PerformEmptyTurn() => await PerformTurn([]);

    async Task PerformTurn(List<Card> cards) => await _connection!.PerformTurn(cards);

    async Task Send(string message) => await _connection!.SendChat(message);

    async Task SetAway(string playerId) => await _connection!.SetAway(playerId);

    async Task VoidTurn(string playerId) => await _connection!.VoidTurn(playerId);

    private async Task CopyRoomId()
    {
        await Clipboard.SetTextAsync(Id.ToString());
        Snackbar.Add("Copied to clipboard.", Severity.Info, c => c.SnackbarVariant = Variant.Text);
    }

    private async Task CopyRoomLink()
    {
        await Clipboard.SetTextAsync(Navigator.Uri);
        Snackbar.Add("Copied to clipboard.", Severity.Info, c => c.SnackbarVariant = Variant.Text);
    }

    public void Dispose()
    {
        _subscriptions.Dispose();
        _room?.Dispose();
        _turn.Dispose();
    }
}