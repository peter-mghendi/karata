@using System.Text.Json
@using System.Collections.Immutable
@implements IGameInterface
@inject ILogger<CardListGameInterface> Logger

<MudGrid Spacing="4" Justify="Justify.Center">
    <MudItem xs="6">
        <MudPaper Class="pa-4" Elevation="0">
            <MudText>Top Card: @Game.Pile.Peek().GetName()</MudText>
            @if (Game.CurrentRequest is not null)
            {
                <MudText>
                    Current Request: @(Game.CurrentRequest.Face is None ? Game.CurrentRequest.Suit.ToString() : Game.CurrentRequest.GetName())
                </MudText>
            }
        </MudPaper>
    </MudItem>
    <MudItem xs="12" sm="6">
        <MudPaper Class="pa-4" Elevation="0">

            <MudText>Player Hands:</MudText>
            @foreach (var hand in OtherHands)
            {
                <MudText>@(hand.User!.Email) has @(hand.Cards.Count) cards.</MudText>
            }
        </MudPaper>
    </MudItem>
</MudGrid>

<MudGrid Spacing="4" Justify="Justify.Center" Class="mb-4">
    <MudItem xs="12" sm="6">
        <MudPaper Elevation="0">
            <MudListSubheader>
                My Cards (click to add to turn)
            </MudListSubheader>
            <MudList Clickable="true">
                @foreach (var card in CurrentHand)
                {
                    <MudListItem Text="@card.GetName()" Icon="@Icons.Rounded.Add" IconColor="Color.Success" OnClick="() => AddCardToTurn(card)" />
                }
            </MudList>
        </MudPaper>
    </MudItem>
    <MudItem xs="6">
        <MudPaper Elevation="0">
            <MudListSubheader>
                This turn (click to remove)
            </MudListSubheader>
            <MudList Clickable="true">
                @foreach (var card in Turn)
                {
                    <MudListItem Text="@card.GetName()" Icon="@Icons.Rounded.Remove" IconColor="Color.Error" OnClick="() => RemoveCardFromTurn(card)" />
                }
            </MudList>
        </MudPaper>
    </MudItem>
</MudGrid>


<MudDropContainer T="DropItem" Items="_items" ItemsSelector="@((DropItem item, string dropzone) => item.Identifier == dropzone)" ItemDropped="ItemUpdated" Class="d-flex flex-wrap flex-grow-1 gap-4">
    <ChildContent>
        <MudDropZone T="DropItem" Identifier="Hand" Class="rounded pa-4 flex-grow-1" Style="background-color: white">
            <MudText Typo="Typo.h6" Class="mb-4">My Cards</MudText>
         </MudDropZone>
        <MudDropZone T="DropItem" Identifier="Turn" Class="rounded pa-4 flex-grow-1" Style="background-color: white" AllowReorder>
            <MudText Typo="Typo.h6" Class="mb-4">Current Turn</MudText>
        </MudDropZone>
    </ChildContent>
    <ItemRenderer>
        <MudPaper Elevation="0" Class="pa-4 my-4 mud-background-gray">@context.Name</MudPaper>
    </ItemRenderer>
</MudDropContainer>

@code
{
    [Parameter]
    public UIGame Game { get; set; }

    [Parameter]
    public UIHand Hand { get; set; }

    [Parameter]
    public ImmutableList<Card> Turn { get; set; } = ImmutableList<Card>.Empty;

    [Parameter]
    public EventCallback<(Card Card, int Index)> OnAddCardToTurn { get; set; }

    [Parameter]
    public EventCallback<(Card Card, int Index)> OnReorderCardInTurn { get; set; }

    [Parameter]
    public EventCallback<Card> OnRemoveCardFromTurn { get; set; }

    private List<Card> CurrentHand => Hand.Cards.Where(c => !Turn.Contains(c)).ToList();

    private List<UIHand> OtherHands => Game.Hands.Where(h => h.User!.Id != Hand.User!.Id).ToList();
  
    private void AddCardToTurn(Card card) => OnAddCardToTurn.InvokeAsync((card, Turn.Count));

    private async Task ReorderCard(Card card, int index) => await OnReorderCardInTurn.InvokeAsync((card, index));

    private void RemoveCardFromTurn(Card card) => OnRemoveCardFromTurn.InvokeAsync(card);

    protected override void OnParametersSet()
    {
        base.OnParametersSet();

        _items.Clear();
        _items.AddRange(CurrentHand.Select(card => new DropItem{ Identifier = "Hand", Card = card }));
        _items.AddRange(Turn.Select(card => new DropItem{ Identifier = "Turn", Card = card }));
    }

    private async Task ItemUpdated(MudItemDropInfo<DropItem> dropItem)
    {
        var zone = dropItem.DropzoneIdentifier;
        var index = dropItem.IndexInZone;
        var item = dropItem.Item;
        var card = item.Card;

        item.Identifier = zone;
        
        switch (zone)
        {
            case "Hand":
            {
                if (!CurrentHand.Contains(card))
                {
                    LogOp(card, index, zone, "Remove");
                    await OnRemoveCardFromTurn.InvokeAsync(card);
                }
                break;
            }
            case "Turn":
            {
                if (!Turn.Contains(card))
                {
                    LogOp(card, index, zone, "Add");
                    await OnAddCardToTurn.InvokeAsync((card, index));
                }
                else
                {
                    LogOp(card, index, zone, "Reorder");
                    await OnReorderCardInTurn.InvokeAsync((card, index));
                }
                break;
            }
        }
    }

    private void LogOp(Card card, int index, string zone, string op)
    {
        Logger.LogInformation("Card: {Card}, Index: {Index}, Zone: {DropZone}, Op: {Op}", card.GetName(), index, zone, op);
    }

    private List<DropItem> _items = new();

    public class DropItem
    {
        public string Identifier = "Hand";
        public string Name => Card.GetName();
        public Card Card { get; init; } 
    }
}